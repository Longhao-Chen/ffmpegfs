<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "https://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=9"/>
<meta name="generator" content="Doxygen 1.9.1"/>
<meta name="viewport" content="width=device-width, initial-scale=1"/>
<title>FFmpegfs Fuse Multi Media Filesystem: FFmpegfs</title>
<link href="tabs.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="jquery.js"></script>
<script type="text/javascript" src="dynsections.js"></script>
<link href="search/search.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="search/searchdata.js"></script>
<script type="text/javascript" src="search/search.js"></script>
<link href="doxygen.css" rel="stylesheet" type="text/css" />
</head>
<body>
<div id="top"><!-- do not remove this div, it is closed by doxygen! -->
<div id="titlearea">
<table cellspacing="0" cellpadding="0">
 <tbody>
 <tr style="height: 56px;">
  <td id="projectalign" style="padding-left: 0.5em;">
   <div id="projectname">FFmpegfs Fuse Multi Media Filesystem
   &#160;<span id="projectnumber">2.3</span>
   </div>
  </td>
 </tr>
 </tbody>
</table>
</div>
<!-- end header part -->
<!-- Generated by Doxygen 1.9.1 -->
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:cf05388f2679ee054f2beb29a391d25f4e673ac3&amp;dn=gpl-2.0.txt GPL-v2 */
var searchBox = new SearchBox("searchBox", "search",false,'Search','.html');
/* @license-end */
</script>
<script type="text/javascript" src="menudata.js"></script>
<script type="text/javascript" src="menu.js"></script>
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:cf05388f2679ee054f2beb29a391d25f4e673ac3&amp;dn=gpl-2.0.txt GPL-v2 */
$(function() {
  initMenu('',true,false,'search.php','Search');
  $(document).ready(function() { init_search(); });
});
/* @license-end */</script>
<div id="main-nav"></div>
<!-- window showing the filter options -->
<div id="MSearchSelectWindow"
     onmouseover="return searchBox.OnSearchSelectShow()"
     onmouseout="return searchBox.OnSearchSelectHide()"
     onkeydown="return searchBox.OnSearchSelectKey(event)">
</div>

<!-- iframe showing the search results (closed by default) -->
<div id="MSearchResultsWindow">
<iframe src="javascript:void(0)" frameborder="0" 
        name="MSearchResults" id="MSearchResults">
</iframe>
</div>

</div><!-- top -->
<div class="PageDoc"><div class="header">
  <div class="headertitle">
<div class="title">FFmpegfs </div>  </div>
</div><!--header-->
<div class="contents">
<div class="textblock"><table class="markdownTable">
<tr class="markdownTableHead">
<th class="markdownTableHeadNone">Branch   </th><th class="markdownTableHeadNone">State   </th><th class="markdownTableHeadNone">Compiler   </th><th class="markdownTableHeadNone">Library   </th><th class="markdownTableHeadNone">Build State    </th></tr>
<tr class="markdownTableRowOdd">
<td class="markdownTableBodyNone"><a href="https://github.com/nschlia/ffmpegfs/tree/master">master</a>   </td><td class="markdownTableBodyNone">testing   </td><td class="markdownTableBodyNone">gcc 8.3.0   </td><td class="markdownTableBodyNone">FFmpeg 4.1.6-1~deb10u1   </td><td class="markdownTableBodyNone"><img src="https://secure.oblivion-software.de/jenkins/buildStatus/icon?job=ffmpegfs%20(github-ffmpeg)" alt="Build Status" class="inline"/>    </td></tr>
<tr class="markdownTableRowEven">
<td class="markdownTableBodyNone"><a href="https://github.com/nschlia/ffmpegfs/tree/master">master</a>   </td><td class="markdownTableBodyNone">testing   </td><td class="markdownTableBodyNone">7.0.1-8+deb10u2   </td><td class="markdownTableBodyNone">FFmpeg 4.1.6-1~deb10u1   </td><td class="markdownTableBodyNone"><img src="https://secure.oblivion-software.de/jenkins/buildStatus/icon?job=ffmpegfs%20(github-ffmpeg-clang)" alt="Build Status" class="inline"/>    </td></tr>
<tr class="markdownTableRowOdd">
<td class="markdownTableBodyNone"><a href="https://github.com/nschlia/ffmpegfs/tree/FB">FB</a>   </td><td class="markdownTableBodyNone">experimental   </td><td class="markdownTableBodyNone">gcc 8.3.0   </td><td class="markdownTableBodyNone">FFmpeg 4.1.6-1~deb10u1   </td><td class="markdownTableBodyNone"><img src="https://secure.oblivion-software.de/jenkins/buildStatus/icon?job=ffmpegfs%20(github-FB-ffmpeg)" alt="Build Status" class="inline"/>    </td></tr>
<tr class="markdownTableRowEven">
<td class="markdownTableBodyNone"><a href="https://github.com/nschlia/ffmpegfs/tree/FB">FB</a>   </td><td class="markdownTableBodyNone">experimental   </td><td class="markdownTableBodyNone">7.0.1-8+deb10u2   </td><td class="markdownTableBodyNone">FFmpeg 4.1.6-1~deb10u1   </td><td class="markdownTableBodyNone"><img src="https://secure.oblivion-software.de/jenkins/buildStatus/icon?job=ffmpegfs%20(github-FB-ffmpeg-clang)" alt="Build Status" class="inline"/>   </td></tr>
</table>
<h1><a class="anchor" id="autotoc_md2"></a>
News</h1>
<ul>
<li>FFmpegfs has been added to Debian 11 Bullseye and Ubuntu 20.04, also to Debian 10 Buster Backports. See <a class="el" href="md_INSTALL.html">INSTALL</a> "Installation from repository" for details.</li>
<li>Cool, there's an online review on Linux Uprising, you can read it here: <a href="https://www.linuxuprising.com/2020/03/ffmpegfs-is-fuse-based-filesystem-for.html">https://www.linuxuprising.com/2020/03/ffmpegfs-is-fuse-based-filesystem-for.html</a></li>
</ul>
<h2><a class="anchor" id="autotoc_md3"></a>
Version 2.3 under development</h2>
<p><b>New in 2.3:</b></p>
<p>Important changes in 2.3 (2021-05-XX)</p>
<ul>
<li><b>Enhancement:</b> <a href="https://github.com/nschlia/ffmpegfs/issues/80">Issue #80</a>: Open input video codec only if target supports video. Saves resources: no need to decode video frames if not used.</li>
<li><b>Enhancement:</b> <a href="https://github.com/nschlia/ffmpegfs/issues/81">Issue #81</a>: If source format has no audio, and the target supports no video (e.g.WAV/MP3), the files have shown up zero sized. These will now not be visible when doing ls. When trying to open them "File not found" will be returned.</li>
<li><b>Added</b> "configure --enable-debug" to create binaries with debug symbols. Defaults to the optimised version.</li>
<li><b>Feature:</b> <a href="https://github.com/nschlia/ffmpegfs/issues/73">Issue #73</a> Cue sheet tracks now play "gapless" if played in order. Whenever a track is started, the next track will automatically be transcoded as well.</li>
<li><b>Feature:</b> <a href="https://github.com/nschlia/ffmpegfs/issues/66">Issue #66</a> and <a href="https://github.com/nschlia/ffmpegfs/issues/82">issue #82</a>: Added cue sheet support. If a file with cue extension is found with the same name as a media file or if a cue sheet is embedded into it (a tag named CUESHEET), tracks defined in it will show up in a virtual directory.</li>
<li><b>Feature:</b> <a href="https://github.com/nschlia/ffmpegfs/issues/83">Issue #83</a>: Character conversion for cue sheet files. Automatically detects the character encoding of the cue sheet. and converts as necessary.</li>
<li><b>Feature:</b> <a href="https://github.com/nschlia/ffmpegfs/issues/78">Issue #78</a>: Duplicate ARTIST to ALBUMARTIST tag if empty.</li>
<li><b>Feature:</b> <a href="https://github.com/nschlia/ffmpegfs/issues/79">Issue #79</a>: Added Docker support. See <a href="README.md#build-a-docker-container">Build A Docker Container</a> how to use it.</li>
<li><b>Fixed deprecation:</b> 2021-03-17 - f7db77bd87 - lavc 58.133.100 - codec.h Deprecated av_init_packet()</li>
<li><b>Fixed API compatitbility:</b> Many pointers made const as of 2021-04-27. Although reasonable, this breaks API compatibility with versions older than 59.0.100,</li>
<li><b>Bugfix:</b> find_original "fallback" method did not correctly handle the new filename format (extension added, not the original one replaced).</li>
<li><b>Bugfix:</b> <a href="https://github.com/nschlia/ffmpegfs/issues/87">Issue #87</a>: Segments are now properly separated, making sure that e.g. segment 3 only goes from 30 seconds up to 40 (including 30, but not 40 seconds).</li>
<li><b>Bugfix:</b> <a href="https://github.com/nschlia/ffmpegfs/issues/88">Issue #88</a>: HLS audio and video now stay in sync after longer playback (more than 30 minutes) or after seek operations.</li>
</ul>
<h2><a class="anchor" id="autotoc_md4"></a>
Version 2.2 released</h2>
<p><b>New in 2.2 (2021-02-06):</b></p>
<ul>
<li><b>Note</b>: This is planned as a maintenance version, no new features but bug fixes only.</li>
<li><b>Bugfix:</b> <a href="https://github.com/nschlia/ffmpegfs/issues/75">Issue #75</a>: Fix crash when opening mp3 output with Dolphin.</li>
<li><b>Bugfix</b>: Possible crash in transcoder_thread: Decoder object could have been used after being freed.</li>
<li><b>Bugfix:</b> Stupid blooper. WAV and AIFF size was always calculated for a mono file, thus for stereo files only half the correct size.</li>
<li><b>Bugfix:</b> <a href="https://github.com/nschlia/ffmpegfs/issues/70">Issue #70</a>: Possible crash in <a class="el" href="classBuffer.html#a6e315544b35bbaf0706ef8fbd6bfdbfb" title="Initialise cache.">Buffer::init</a>: Should not assert if duration is 0 (and thus segment count 0). Report internal error and go on.</li>
<li><b>Bugfix:</b> <a href="https://github.com/nschlia/ffmpegfs/issues/70">Issue #70</a>: Do not set duration to 0 from cache but leave unchanged. Caused HLS transcoding to fail if more than one transcoder was concurrently started.</li>
<li><b>Bugfix:</b> Corrected documentation, "make checks" should read "make check", funny this went unnoticed for over 3 years...</li>
<li><b>Bugfix:</b> <a href="https://github.com/nschlia/ffmpegfs/issues/74">Issue #74</a>: Album arts were only copied from MP3/4 sources. Removed restriction, if the input file contains an album art it will be copied to the target (if supported, of course, e.g., to mp3 or mp4. Ogg is not yet supported because embedding album arts in Ogg can only be done by an unofficial workaround).</li>
<li><b>Bugfix:</b> <a href="https://github.com/nschlia/ffmpegfs/issues/71">Issue #71</a>: Virtual directories were missing dot and dot-dot nodes.</li>
</ul>
<h2><a class="anchor" id="autotoc_md5"></a>
Version 2.1 released</h2>
<p><b>New in 2.1 (2020-12-14):</b></p>
<ul>
<li><b>Feature</b>: Add BLURAY_VIDEO_FORMAT_2160P (UHD)</li>
<li><b>Feature</b>: Implemented in 1.7, removed experimental state for &ndash;win_smb_fix now. Windows seems to access the files on Samba drives starting at the last 64K segment simply when the file is opened. Setting &ndash;win_smb_fix=1 will ignore these attempts (not decode the file up to this point).</li>
<li><b>Feature</b>: &ndash;win_smb_fix now defaults to 1 (fix on by default). Has no effect if the drive is accessed directly or via Samba from Linux.</li>
<li><b>Bugfix</b>: Fixed grammatical error in text: It's "access to", not "access at".</li>
<li><b>Bugfix</b>: Did not transcode some source files with invalid DTS.</li>
<li><b>Bugfix</b>: Cosmetical - No need to log date/time twice in syslog.</li>
<li><b>Bugfix</b>: Cosmetical - Fix man page/online help for &ndash;recodesame parameter.</li>
<li><b>Bugfix</b>: Report correct segment duration</li>
<li><b>Bugfix</b>: Avoid crash if opening next HLS segment failed. Should not ignore this, but report it instead and stop transcoding.</li>
<li><b>Cosmetical</b>: Log cache close action at trace level</li>
<li><b>Cosmetical</b>: Shorter log entry when opening cache files</li>
</ul>
<h2><a class="anchor" id="autotoc_md6"></a>
Planned Features</h2>
<ul>
<li><a href="https://github.com/nschlia/ffmpegfs/issues/63">Issue #63</a>: Interesting feature request - hardware support for encoding and decoding has been added. If you feel lucky do "git checkout FB" and try it out.</li>
<li>Currently I am preparing a Windows version, but this is going to take some time.</li>
</ul>
<h1><a class="anchor" id="autotoc_md7"></a>
About</h1>
<p>Web site: <a href="https://nschlia.github.io/ffmpegfs/">https://nschlia.github.io/ffmpegfs/</a></p>
<p>FFmpegfs is a read-only FUSE filesystem which transcodes between audio and video formats on the fly when opened and read.</p>
<p>Currently supported output formats:</p>
<table class="markdownTable">
<tr class="markdownTableHead">
<th class="markdownTableHeadNone">Format   </th><th class="markdownTableHeadNone">Description   </th><th class="markdownTableHeadNone">Video   </th><th class="markdownTableHeadNone">Audio    </th></tr>
<tr class="markdownTableRowOdd">
<td class="markdownTableBodyNone">MP4   </td><td class="markdownTableBodyNone">MPEG-4   </td><td class="markdownTableBodyNone">H264   </td><td class="markdownTableBodyNone">AAC    </td></tr>
<tr class="markdownTableRowEven">
<td class="markdownTableBodyNone" colspan="2">WebM   </td><td class="markdownTableBodyNone">VP9   </td><td class="markdownTableBodyNone">Opus    </td></tr>
<tr class="markdownTableRowOdd">
<td class="markdownTableBodyNone" colspan="2">OGG   </td><td class="markdownTableBodyNone">Theora   </td><td class="markdownTableBodyNone">Vorbis    </td></tr>
<tr class="markdownTableRowEven">
<td class="markdownTableBodyNone">MOV   </td><td class="markdownTableBodyNone">QuickTime File Format   </td><td class="markdownTableBodyNone">H264   </td><td class="markdownTableBodyNone">AAC    </td></tr>
<tr class="markdownTableRowOdd">
<td class="markdownTableBodyNone">ProRes   </td><td class="markdownTableBodyNone">Apple ProRes   </td><td class="markdownTableBodyNone">ProRes   </td><td class="markdownTableBodyNone">PCM 16 bit LE    </td></tr>
<tr class="markdownTableRowEven">
<td class="markdownTableBodyNone" colspan="3">Opus   </td><td class="markdownTableBodyNone">Opus    </td></tr>
<tr class="markdownTableRowOdd">
<td class="markdownTableBodyNone">MP3   </td><td class="markdownTableBodyNone" colspan="2">MPEG-2 Audio Layer III   </td><td class="markdownTableBodyNone">MP3    </td></tr>
<tr class="markdownTableRowEven">
<td class="markdownTableBodyNone">WAV   </td><td class="markdownTableBodyNone" colspan="2">Waveform Audio File Format   </td><td class="markdownTableBodyNone">PCM 16 bit LE    </td></tr>
<tr class="markdownTableRowOdd">
<td class="markdownTableBodyNone">AIFF   </td><td class="markdownTableBodyNone" colspan="2">Audio Interchange File Format   </td><td class="markdownTableBodyNone">PCM 16 bit BE    </td></tr>
<tr class="markdownTableRowEven">
<td class="markdownTableBodyNone">ALAC   </td><td class="markdownTableBodyNone" colspan="2">Apple Lossless Audio Codec   </td><td class="markdownTableBodyNone">ALAC    </td></tr>
<tr class="markdownTableRowOdd">
<td class="markdownTableBodyNone">JPG   </td><td class="markdownTableBodyNone">Video to frameset   </td><td class="markdownTableBodyNone">JPEG   </td><td class="markdownTableBodyNone"></td></tr>
<tr class="markdownTableRowEven">
<td class="markdownTableBodyNone">PNG   </td><td class="markdownTableBodyNone">Video to frameset   </td><td class="markdownTableBodyNone">PNG   </td><td class="markdownTableBodyNone"></td></tr>
<tr class="markdownTableRowOdd">
<td class="markdownTableBodyNone">BMP   </td><td class="markdownTableBodyNone">Video to frameset   </td><td class="markdownTableBodyNone">BMP   </td><td class="markdownTableBodyNone"></td></tr>
<tr class="markdownTableRowEven">
<td class="markdownTableBodyNone">TS   </td><td class="markdownTableBodyNone">MPEG Transport Stream   </td><td class="markdownTableBodyNone">H264   </td><td class="markdownTableBodyNone">AAC    </td></tr>
<tr class="markdownTableRowOdd">
<td class="markdownTableBodyNone">HLS   </td><td class="markdownTableBodyNone">HTTP Live Streaming   </td><td class="markdownTableBodyNone">H264   </td><td class="markdownTableBodyNone">AAC   </td></tr>
</table>
<p>This can let you use a multi media file collection with software and/or hardware which only understands one of the supported output formats, or transcode files through simple drag-and-drop in a file browser.</p>
<p>For live streaming select <em>WebM</em> or <em>MP4</em> for best results. If video transcoding is not required <em>MP3</em> will also do, but <em>WebM</em> and <em>MP4</em> create better results. The <em>OGG</em> encoder is not fast enough for real-time recoding files.</p>
<p>When a destination <em>JPG</em>, <em>PNG</em> or <em>BMP</em> is chosen, all frames of a video source file will be presented in a virtual directory named after the source file. Audio will not be available.</p>
<p>Selecting <em>HLS</em> creates a directory with TS segments together with a M3U playlist (index_0_av.m3u8 and master.m3u8). There is also a hls.html that can be opened in a browser to play the segments.</p>
<p>Please note that the files must be on a web server because restrictions prevent most browsers from opening the files from disk. See <a href="README.md#fixing-problems">FIXING PROBLEMS</a> for details.</p>
<h1><a class="anchor" id="autotoc_md8"></a>
Installation Instructions</h1>
<ul>
<li>Please read the <a class="el" href="md_INSTALL.html">INSTALL</a> file.</li>
</ul>
<h1><a class="anchor" id="autotoc_md9"></a>
Supported Linux Distributions</h1>
<p>Tested with:</p>
<table class="markdownTable">
<tr class="markdownTableHead">
<th class="markdownTableHeadNone">Distribution   </th><th class="markdownTableHeadNone">FFmpeg Version   </th><th class="markdownTableHeadNone">Remarks   </th><th class="markdownTableHeadNone">Result    </th></tr>
<tr class="markdownTableRowOdd">
<td class="markdownTableBodyNone"><code>Daily build</code>   </td><td class="markdownTableBodyNone"><b>N-99880-g8fbcc546b8</b>   </td><td class="markdownTableBodyNone"></td><td class="markdownTableBodyNone">OK    </td></tr>
<tr class="markdownTableRowEven">
<td class="markdownTableBodyNone"><code>Debian 9 Stretch</code>   </td><td class="markdownTableBodyNone"><b>3.2.8-1~deb9u1</b>   </td><td class="markdownTableBodyNone"></td><td class="markdownTableBodyNone">OK    </td></tr>
<tr class="markdownTableRowOdd">
<td class="markdownTableBodyNone"><code>Debian 10 Buster</code>   </td><td class="markdownTableBodyNone"><b>4.1.6-1~deb10u1</b>   </td><td class="markdownTableBodyNone"></td><td class="markdownTableBodyNone">OK    </td></tr>
<tr class="markdownTableRowEven">
<td class="markdownTableBodyNone"><code>Debian 11 Bullseye</code>   </td><td class="markdownTableBodyNone"><b>4.3.1-5</b>   </td><td class="markdownTableBodyNone"></td><td class="markdownTableBodyNone">OK    </td></tr>
<tr class="markdownTableRowOdd">
<td class="markdownTableBodyNone"><code>Raspbian 10 Buster</code>   </td><td class="markdownTableBodyNone"><b>4.1.6-1~deb10u1+rpt1</b>   </td><td class="markdownTableBodyNone"></td><td class="markdownTableBodyNone">OK    </td></tr>
<tr class="markdownTableRowEven">
<td class="markdownTableBodyNone"><code>Ubuntu 16.04.3 LTS</code>   </td><td class="markdownTableBodyNone">**.8.11-0ubuntu0.16.04.1**   </td><td class="markdownTableBodyNone"></td><td class="markdownTableBodyNone">OK    </td></tr>
<tr class="markdownTableRowOdd">
<td class="markdownTableBodyNone"><code>Ubuntu 17.10</code>   </td><td class="markdownTableBodyNone"><b>3.3.4-2</b>   </td><td class="markdownTableBodyNone"></td><td class="markdownTableBodyNone">OK    </td></tr>
<tr class="markdownTableRowEven">
<td class="markdownTableBodyNone"><code>Ubuntu 20.04</code>   </td><td class="markdownTableBodyNone"><b>4.2.2-1ubuntu1</b>   </td><td class="markdownTableBodyNone"></td><td class="markdownTableBodyNone">OK    </td></tr>
<tr class="markdownTableRowOdd">
<td class="markdownTableBodyNone"><code>Suse 42</code>   </td><td class="markdownTableBodyNone"><b>3.3.4</b>   </td><td class="markdownTableBodyNone">See notes below   </td><td class="markdownTableBodyNone">not OK    </td></tr>
<tr class="markdownTableRowEven">
<td class="markdownTableBodyNone"><code>Red Hat 7</code>   </td><td class="markdownTableBodyNone"><b>FFmpeg must be compiled from sources</b>   </td><td class="markdownTableBodyNone"></td><td class="markdownTableBodyNone">OK    </td></tr>
<tr class="markdownTableRowOdd">
<td class="markdownTableBodyNone"><code>Funtoo 7.3.1</code>   </td><td class="markdownTableBodyNone"><b>3.4.1</b>   </td><td class="markdownTableBodyNone">FFmpeg needs to be installed with correct "USE flags", see <a class="el" href="md_INSTALL.html">install</a>   </td><td class="markdownTableBodyNone">OK   </td></tr>
</table>
<p><b>Suse</b> does not provide proprietary formats like AAC and H264, thus the distribution FFmpeg is crippled. FFmpegfs will not be able to encode to H264 and AAC. End of story.</p>
<p>See <a href="https://en.opensuse.org/Restricted_formats">https://en.opensuse.org/Restricted_formats</a>.</p>
<p><b>Tips on other OSs and distributions like Mac or other *nixes are welcome.</b></p>
<h1><a class="anchor" id="autotoc_md10"></a>
Usage</h1>
<p>Mount your file system like this: </p><pre class="fragment">ffmpegfs [--audiobitrate bitrate] [--videobitrate bitrate] musicdir mountpoint [-o fuse_options]
</pre><p> For example, to run FFmpegfs as daemon and encode to MPEG-4: </p><pre class="fragment">ffmpegfs --audiobitrate=256K --videobitrate=1.5M /mnt/music /mnt/ffmpegfs -o allow_other,ro,desttype=mp4
</pre><p> This will run FFmpegfs in the foreground and print the log output to the screen: </p><pre class="fragment">ffmpegfs -f --log_stderr --audiobitrate=256K --videobitrate=1.5M --audiobitrate=256K --videobitrate=1.5M /mnt/music /mnt/ffmpegfs -o allow_other,ro,desttype=mp4
</pre><p> In recent versions of FUSE the same can be achieved with the following entry in <code>/etc/fstab</code>: </p><pre class="fragment">ffmpegfs#/mnt/music /mnt/ffmpegfs fuse allow_other,ro,audiobitrate=256K,videobitrate=2000000,desttype=mp4 0 0
</pre><p> Another (more modern) form of this command: </p><pre class="fragment">/mnt/music /mnt/ffmpegfs fuse.ffmpegfs allow_other,ro,audiobitrate=256K,videobitrate=2000000,desttype=mp4 0 0
</pre><p> At this point files like <code>/mnt/music/**.flac</code> and <code>/mnt/music/**.ogg</code> will show up as <code>/mnt/ffmpegfs/**.mp4</code>.</p>
<p>Audio bitrates will be reduced to 256 KBit, video to 1.5 MBit. If the source bitrate is less it will not be scaled up but rather left at the lower value.</p>
<p>Note that the "allow_other" option by default can only be used by root. You must either run FFmpegfs as root or better add a "user_allow_other" key to /etc/fuse.conf.</p>
<p>"allow_other" is required to allow any user access to the mount, by default this is only possible for the user who launched FFmpegfs.</p>
<p>Examples: </p><pre class="fragment">ffmpegfs -f $HOME/test/in $HOME/test/out --log_stderr --log_maxlevel=DEBUG -o allow_other,ro,desttype=mp4,cachepath=$HOME/test/cache
</pre><p> Run FFmpegfs transcoding files from /test/in to /test/out, logging up to a chatty TRACE level to stderr. The cache resides in test/cache. All directories are under the current user's home directory. </p><pre class="fragment"> ffmpegfs -f $HOME/test/in $HOME/test/out --log_stderr --log_maxlevel=DEBUG -o allow_other,ro,desttype=mp4,cachepath=$HOME/test/cache,videowidth=640
</pre><p> Same as above, but also limit video with to 640 pixels. Larger videos will be scaled down, preserving the aspect ratio. Smaller videos will not be scaled up. </p><pre class="fragment"> ffmpegfs -f $HOME/test/in $HOME/test/out --log_stderr --log_maxlevel=DEBUG -o allow_other,ro,desttype=mp4,cachepath=$HOME/test/cache,deinterlace
</pre><p> Enable deinterlacing for enhanced image quality.</p>
<h1><a class="anchor" id="autotoc_md11"></a>
HTTP Live Streaming</h1>
<p>FFmpegfs now supports HLS (HTTP Live Streaming). FFmpegfs will create transport stream (ts) segments and the required m3u8 playlists. For your convenience it will also offer a virtual test.html file that can playback the segments using the hls.js library (see <a href="https://github.com/video-dev/hls.js/">https://github.com/video-dev/hls.js/</a>).</p>
<p>To use the new HLS feature invoke FFmpegfs with: </p><pre class="fragment"> ffmpegfs -f $HOME/test/in $HOME/test/out -o allow_other,ro,desttype=hls
</pre><p> Please note that this will only work over http, because most browsers refuse to load multimedia files from the local file system, so you need to publish the directory on a web server. Security restrictions prevent direct playback from disk. Simply navigate to the directory and open test.html.</p>
<h1><a class="anchor" id="autotoc_md12"></a>
Cue Sheets</h1>
<p>Cue sheets, or cue sheet files, were first introduced for the CDRWIN CD/DVD burning software. Basically they are used to define a CD/DVD track layout. Today they are supported by a wide range of optical disc authoring applications, and moreover, media players.</p>
<p>When a media file is accompanied by a cue sheet, its contents are read and a virtual directory with separate tracks is created. The cue sheet file must have the same name, but the extension ".cue" instead. It can also be embedded into the media file.</p>
<p>The directory is named after the source media, with an additional ".tracks" extension. If several media files with different extensions exist, for example, different formats, several ".tracks" directories will be visible.</p>
<p>Example: </p><pre class="fragment"> myfile.mp4
 myfile.ogv
 myfile.cue
</pre><p> If destination type is TS, the following files and directories will appear: </p><pre class="fragment"> myfile.mp4
 myfile.mp4.ts
 myfile.ogv
 myfile.ogv.ts
 myfile.cue
 myfile.mp4.tracks/
 myfile.ogv.tracks/
</pre><p> Tracks defined in the cue sheet will show up in the *.tracks sub directories.</p>
<h1><a class="anchor" id="autotoc_md13"></a>
Building A Docker Container</h1>
<p>FFmpegfs can run under Docker. To build a container for FFmpegfs a Dockerfile is provided. Change to the docker directory and run </p><pre class="fragment"> docker build --build-arg -t nschlia/ffmpegfs .
</pre><p> Depending on the machine speed, this will take quite a while. After the command completed, the container can be started with </p><pre class="fragment"> docker run --rm \
      --name=ffmpegfs \
      --device /dev/fuse \
      --cap-add SYS_ADMIN \
      --security-opt apparmor:unconfined \
      -v /path/to/source:/src:ro \
      -v /path/to/output:/dst:rshared \
      nschlia/ffmpegfs \
      -f --log_stderr --audiobitrate=256K -o allow_other,ro,desttype=mp3,log_maxlevel=INFO
</pre><p> Of course, */path/to/source* must be changed to a directory with multi media files and */path/to/output* to where the converted files should be visible. desttype may be changed to MP4 or whatever desired.</p>
<h1><a class="anchor" id="autotoc_md14"></a>
Auto Copy</h1>
<p>"Auto copy" performs intelligent stream copy, for example, if transcoding a transport stream that already represents a H264 video and/or AAC audio stream it is possible to simply repackage it to a mp4 container without recoding.</p>
<p>This is very efficient as it does not require as much computing as de- and encoding does, and it also will not degrade quality as the original file basically stays the same.</p>
<p>The function detects if the target format supports the source codec and simply remuxes the stream even if recoding from one format (for example TS) to another (for example MOV, MP4).</p>
<p>There are three options:</p>
<table class="markdownTable">
<tr class="markdownTableHead">
<th class="markdownTableHeadNone">Option   </th><th class="markdownTableHeadNone">Description    </th></tr>
<tr class="markdownTableRowOdd">
<td class="markdownTableBodyNone">OFF   </td><td class="markdownTableBodyNone">no auto copy    </td></tr>
<tr class="markdownTableRowEven">
<td class="markdownTableBodyNone">LIMIT   </td><td class="markdownTableBodyNone">only auto copy if target file will not become significantly larger    </td></tr>
<tr class="markdownTableRowOdd">
<td class="markdownTableBodyNone">ALWAY   </td><td class="markdownTableBodyNone">auto copy whenever possible even if the target file becomes larger   </td></tr>
</table>
<h1><a class="anchor" id="autotoc_md15"></a>
Smart Transcoding</h1>
<p>Smart transcoding can create different output formats for video and audio files. For example, video files can be converted to ProRes and audio files to AIFF. Of course, combinations like MP4/MP3 or WebM/WAV are possible but do not make sense as MP4 or WebM work perfectly with audio only content.</p>
<p>To use the new feature, simply specify a video and audio file type, separated by a "+" sign. For example, &ndash;desttype=mov+aiff will convert video files to Apple Quicktime MOV and audio only files to AIFF. This can be handy if the results are consumed for example by some Apple Editing software which is very picky about the input format.</p>
<p><em>Note</em></p>
<p>Smart transcoding currently simply determines the output format by taking the input format type into account, e.g., an MP3 would be recoded to AIFF, an MP4 to MOV even if the input MP4 does not contain a video stream.</p>
<p>The input format should be scanned for streams and the output selected appropriately: An MP4 with video should be transcoded to MOV, an MP4 with audio only to AIFF. See <a href="https://github.com/nschlia/ffmpegfs/issues/86">Issue #86</a>.</p>
<h1><a class="anchor" id="autotoc_md16"></a>
Transcode To Frame Images</h1>
<p>To transcode a video to frame images, set the destination type to JPG, PNG or BMP. This will convert videos to virtual folders with images for each frame.</p>
<div class="fragment"><div class="line">$ ls /storage/videos</div>
<div class="line">  video1.mp4</div>
<div class="line">  video2.mov</div>
<div class="line"> </div>
<div class="line">$ ffmpegfs /storage/videos /mnt/ffmpegfs</div>
<div class="line">$ find /mnt/ffmpegfs</div>
<div class="line">  /mnt/ffmpegfs/video1.mp4/00001.png</div>
<div class="line">  /mnt/ffmpegfs/video1.mp4/00002.png</div>
<div class="line">  ...</div>
<div class="line">  /mnt/ffmpegfs/video1.mov/00001.png</div>
<div class="line">  /mnt/ffmpegfs/video1.mov/00002.png</div>
</div><!-- fragment --><h1><a class="anchor" id="autotoc_md17"></a>
A Few Words On ProRes</h1>
<p>Apple's ProRes is a so-called intermediate format, intended for post-production editing. It combines highest possible quality while still saving some disk space and not requiring high performance disk systems. On the other hand this means that ProRes encoded videos will become quite large - for example a 60 minute video may require up to 25 GB.</p>
<p>It is not for target audience use, and certainly not suitable for internet streaming.</p>
<p>Also please keep in mind that when using lossy source input formats the quality will not get better, but the files can be fed into software like Final Cut Pro which only accepts a small number of input formats.</p>
<h1><a class="anchor" id="autotoc_md18"></a>
MP4 Format Profiles</h1>
<p>The MP4 container has several derivative formats that are not compatible with all target audiences. To successfully feed the resulting files into, for example, MS Edge, the subformat must be different as for Firefox, unfortunately.</p>
<p>The &ndash;profile option allows to select the format:</p>
<table class="markdownTable">
<tr class="markdownTableHead">
<th class="markdownTableHeadNone">Profile   </th><th class="markdownTableHeadNone">OS   </th><th class="markdownTableHeadNone">Target   </th><th class="markdownTableHeadNone">Remarks    </th></tr>
<tr class="markdownTableRowOdd">
<td class="markdownTableBodyNone">NONE   </td><td class="markdownTableBodyNone">all   </td><td class="markdownTableBodyNone">VLC, Windows Media Player etc.   </td><td class="markdownTableBodyNone">Playback (default)    </td></tr>
<tr class="markdownTableRowEven">
<td class="markdownTableBodyNone">FF   </td><td class="markdownTableBodyNone">Linux, Win10, Android   </td><td class="markdownTableBodyNone">Firefox   </td><td class="markdownTableBodyNone">OK: Playback while transcoding    </td></tr>
<tr class="markdownTableRowOdd">
<td class="markdownTableBodyNone"></td><td class="markdownTableBodyNone">Win7   </td><td class="markdownTableBodyNone">Firefox   </td><td class="markdownTableBodyNone">OK: Playback while transcoding    </td></tr>
<tr class="markdownTableRowEven">
<td class="markdownTableBodyNone">EDGE   </td><td class="markdownTableBodyNone">Win10   </td><td class="markdownTableBodyNone">MS Edge, IE &gt; 11   </td><td class="markdownTableBodyNone">OK: Playback while transcoding    </td></tr>
<tr class="markdownTableRowOdd">
<td class="markdownTableBodyNone"></td><td class="markdownTableBodyNone">Win10 Mobile   </td><td class="markdownTableBodyNone"></td><td class="markdownTableBodyNone">OK: Playback while transcoding    </td></tr>
<tr class="markdownTableRowEven">
<td class="markdownTableBodyNone">IE   </td><td class="markdownTableBodyNone">Win10   </td><td class="markdownTableBodyNone">MS IE &lt;= 11   </td><td class="markdownTableBodyNone">OK: Playback while transcoding    </td></tr>
<tr class="markdownTableRowOdd">
<td class="markdownTableBodyNone"></td><td class="markdownTableBodyNone">Win7   </td><td class="markdownTableBodyNone"></td><td class="markdownTableBodyNone">Must decode first (1)    </td></tr>
<tr class="markdownTableRowEven">
<td class="markdownTableBodyNone">CHROME   </td><td class="markdownTableBodyNone">all   </td><td class="markdownTableBodyNone">Google Chrome   </td><td class="markdownTableBodyNone">Must decode first (1)    </td></tr>
<tr class="markdownTableRowOdd">
<td class="markdownTableBodyNone">SAFARI   </td><td class="markdownTableBodyNone">Win   </td><td class="markdownTableBodyNone">Apple Safari   </td><td class="markdownTableBodyNone">Must decode first (1)    </td></tr>
<tr class="markdownTableRowEven">
<td class="markdownTableBodyNone">OPERA   </td><td class="markdownTableBodyNone">All   </td><td class="markdownTableBodyNone">Opera   </td><td class="markdownTableBodyNone">Must decode first (1)    </td></tr>
<tr class="markdownTableRowOdd">
<td class="markdownTableBodyNone">MAXTHON   </td><td class="markdownTableBodyNone">Win   </td><td class="markdownTableBodyNone">Maxthon   </td><td class="markdownTableBodyNone">Must decode first (1)   </td></tr>
</table>
<p>(1)</p><ul>
<li>error message when opened while transcoding</li>
<li>must start again when file was transcoded</li>
<li>Plays fine when file comes directly from buffer</li>
</ul>
<p>This all boils down to the fact than Firefox and Edge are the only browsers that support the necessary extensions to start playback while still transcoding.</p>
<p>In most cases files will not play if not properly optimised.</p>
<p>See [TODO](TODO) for details.</p>
<h1><a class="anchor" id="autotoc_md19"></a>
How It Works</h1>
<p>When a file is opened, the decoder and encoder are initialised and the file metadata is read. At this time the final filesize can be determined approximately. This works well for MP3, AIFF or WAV output files, but only fair to good for MP4 or WebM because the actual size heavily depends on the content encoded.</p>
<p>As the file is read, it is transcoded into an internal per-file buffer. This buffer continues to grow while the file is being read until the whole file is transcoded in memory. Once decoded the file is kept in a disk buffer and can be accessed very fast.</p>
<p>Transcoding is done in an extra thread, so if other processes should access the same file they will share the same transcoded data, saving CPU time. If all processes close the file before its end, transcoding will continue for some time. If the file is accessed again before timeout, transcoding will continue, if not it stops and the chunk created so far discarded to save disk space.</p>
<p>Seeking within a file will cause the file to be transcoded up to the seek point (if not already done). This is not usually a problem since most programs will read a file from start to finish. Future enhancements may provide true random seeking (but if this is feasible is yet unclear due to restrictions to positioning inside compressed streams). This already works when HLS streaming is selected. FFmpegfs simply skips to the requested segment.</p>
<p>MP3: ID3 version 2.4 and 1.1 tags are created from the comments in the source file. They are located at the start and end of the file respectively.</p>
<p>MP4: Same applies to meta atoms in MP4 containers.</p>
<p>MP3 target only: A special optimisation is made so that applications which scan for id3v1 tags do not have to wait for the whole file to be transcoded before reading the tag. This <em>dramatically</em> speeds up such applications.</p>
<p>WAV: A pro format WAV header will be created with estimates of the WAV file size. This header will be replaced when the file is finished. It does not seem necessary, though, as most modern players obviously ignore this information and play the file anyway.</p>
<h1><a class="anchor" id="autotoc_md20"></a>
About Output Formats</h1>
<p>A few words to the supported output formats. There is not much to say about the MP3 output as these are regular constant bitrate (CBR) MP3 files with no strings attached. They should play well in any modern player.</p>
<p>MP4 files are special, though, as regular MP4s are not quite suited for live streaming. Reason being that the start block of an MP4 contains a field with the size of the compressed data section. Suffice to say that this field cannot be filled in until the size is known, which means compression must be completed first, a file seek done to the beginning, and the size atom updated.</p>
<p>For a continuous live stream, that size will never be known. For our transcoded files one would have to wait for the whole file to be recoded to get that value. If that was not enough some important pieces of information are located at the end of the file, including meta tags with artist, album, etc. Also, there is only one big data block, a fact that hampers random seek inside the contents without having the complete data section.</p>
<p>Subsequently many applications will go to the end of an MP4 to read important information before going back to the head of the file and start playing. This will break the whole transcode-on-demand idea of FFmpegfs.</p>
<p>To get around the restriction several extensions have been developed, one of which is called "faststart" that relocates the aforementioned meta data from the end to the beginning of the MP4. Additionally, the size field can be left empty (0). isml (smooth live streaming) is another extension.</p>
<p>For direct to stream transcoding several new features in MP4 need to be active (ISMV, faststart, separate_moof/empty_moov to name them) which are not implemented in older versions of FFmpeg (or if available, not working properly).</p>
<p>By default faststart files will be created with an empty size field so that the file can be started to be written out at once instead of encoding it as a whole before this is possible. Encoding it completely would mean it would take some time before playback can start.</p>
<p>The data part is divided into chunks of about 1 second length, each with its own header, thus it is possible to fill in the size fields early enough.</p>
<p>As a draw back not all players support the format, or play it with strange side effects. VLC plays the file, but updates the time display every few seconds only. When streamed over HTML5 video tags, sometimes there will be no total time shown, but that is OK, as long as the file plays. Playback cannot be positioned past the current playback position, only backwards.</p>
<p>But that's the price of starting playback fast.</p>
<h1><a class="anchor" id="autotoc_md21"></a>
Fixing Problems</h1>
<h2><a class="anchor" id="autotoc_md22"></a>
Transcoding too slow</h2>
<p>See <a href="INSTALL.md#building-ffmpeg-with-optimisations">Building FFmpeg with optimisations</a></p>
<h2><a class="anchor" id="autotoc_md23"></a>
Lock ups when accessed through Samba</h2>
<p>When accessed one a Samba drive, the pending read can lock the whole share, causing Windows Explorer and even KDE Dolphin to freeze. Any access from the same machine to that share is blocked, Even "ls" is not possible and blocks until the data was returned.</p>
<p>Seems others had the same problem:</p>
<p><a href="http://samba.2283325.n4.nabble.com/Hangs-Accessing-fuse-filesystem-in-Windows-through-Samba-td4681904.html">http://samba.2283325.n4.nabble.com/Hangs-Accessing-fuse-filesystem-in-Windows-through-Samba-td4681904.html</a></p>
<p>Adding this to the [global] config in smb.conf fixes that: </p><pre class="fragment">oplocks = no
level2 oplocks = no
aio read size = 1
</pre><p> The "aio read size" parameter may be moved to the share config: </p><pre class="fragment">aio read size = 1
</pre> <h2><a class="anchor" id="autotoc_md24"></a>
rsync, Beyond Compare and other tools</h2>
<p>Some copy tools do not go along very well with dynamically generated files as in <a href="https://github.com/nschlia/ffmpegfs/issues/22">Issue #23: Partial transcode of some files</a>.</p>
<p>Under Linux it is best to use (optionally with -r parameter) </p><pre class="fragment">    cp -uv /path/to/source /path/to/target
</pre><p> This will copy all missing/changed files without missing parts. On the Windows side, Windows Explorer or copy/xcopy work. Tools like Beyond Compare may only copy the predicted size first and not respond to size changes.</p>
<h2><a class="anchor" id="autotoc_md25"></a>
Play HLS output by opening hls.html from disk</h2>
<p>Most browser prevent playback of files from disk. You may put them into a website directory, but sometimes even https must be used or playback will be blocked.</p>
<p><b>To enable disk playback in Firefox:</b></p>
<ul>
<li>Open about:config</li>
<li>Set security.fileuri.strict_origin_policy to false</li>
</ul>
<h2><a class="anchor" id="autotoc_md26"></a>
Songs get cut short</h2>
<p>If songs do not play to the very end and you are using SAMBA or NFS you're in trouble.</p>
<p>Happens when the files are transcoded on the fly, but never when file comes from cache. This is because the result is never exactly what was predicted.</p>
<p>SAMBA fills files with zeros if the result is smaller, or cuts off the rest if the file ist larger than predicted.</p>
<p>NFS arbitrarily sends the correct file, or one that is cut or padded like SAMBA. This can be repeated as many times as one wants to - once the file is OK, once not.</p>
<p>As of yet there seems to be no way around that. Maybe NFS or SAMBA can be configured to cope with that, but how to is unknown to me.</p>
<h1><a class="anchor" id="autotoc_md27"></a>
Development</h1>
<p>FFmpegfs uses Git for revision control. You can obtain the full repository with: </p><pre class="fragment">git clone https://github.com/nschlia/ffmpegfs.git
</pre><p> FFmpegfs is written in a little bit of C and mostly C++11. It uses the following libraries:</p>
<ul>
<li><a href="http://fuse.sourceforge.net/">FUSE</a></li>
</ul>
<p>FFmpeg library:</p>
<ul>
<li><a href="https://www.FFmpeg.org/">FFmpeg</a></li>
</ul>
<p>Please note that FFmpegfs is in active development, so the main branch may be unstable (but offer nice gimmicks, though). If you need a stable version please get one (preferrably the latest) release.</p>
<p>Feel free to clone this project and add your own features. If they are interesting for others they might be pushed back into this project. Same applies to bug fixes, if you discover a bug your welcome to fix it!</p>
<h1><a class="anchor" id="autotoc_md28"></a>
Future Plans</h1>
<ul>
<li>Create a windows version</li>
<li>and more, see [TODO](TODO)</li>
</ul>
<h1><a class="anchor" id="autotoc_md29"></a>
Demo Code</h1>
<p>HLS player and demo code see: <a href="https://github.com/video-dev/hls.js/">https://github.com/video-dev/hls.js/</a></p>
<h1><a class="anchor" id="autotoc_md30"></a>
Authors</h1>
<p>This fork with FFmpeg support is maintained by Norbert Schlia (<a href="#" onclick="location.href='mai'+'lto:'+'nsc'+'hl'+'ia@'+'ob'+'liv'+'io'+'n-s'+'of'+'twa'+'re'+'.de'; return false;">nschl<span style="display: none;">.nosp@m.</span>ia@o<span style="display: none;">.nosp@m.</span>blivi<span style="display: none;">.nosp@m.</span>on-s<span style="display: none;">.nosp@m.</span>oftwa<span style="display: none;">.nosp@m.</span>re.d<span style="display: none;">.nosp@m.</span>e</a>) since 2017 to date.</p>
<p>Based on work by K. Henriksson (from 2008 to 2017) and the original author David Collett (from 2006 to 2008).</p>
<p>Much thanks to them for the original work and giving me a good head start!</p>
<h1><a class="anchor" id="autotoc_md31"></a>
License</h1>
<p>This program can be distributed under the terms of the GNU GPL version 3 or later. It can be found <a href="http://www.gnu.org/licenses/gpl-3.0.html">online</a> or in the COPYING file.</p>
<p>This and other documentation may be distributed under the GNU Free Documentation License (GFDL) 1.3 or later with no invariant sections, or alternatively under the GNU General Public License (GPL) version 3 or later. The GFDL can be found <a href="http://www.gnu.org/licenses/fdl-1.3.html">online</a> or in the COPYING.DOC file.</p>
<h1><a class="anchor" id="autotoc_md32"></a>
FFmpeg License</h1>
<p>FFmpeg is licensed under the GNU Lesser General Public License (LGPL) version 2.1 or later. However, FFmpeg incorporates several optional parts and optimizations that are covered by the GNU General Public License (GPL) version 2 or later. If those parts get used the GPL applies to all of FFmpeg.</p>
<p>See <a href="https://www.ffmpeg.org/legal.html">https://www.ffmpeg.org/legal.html</a> for details.</p>
<h1><a class="anchor" id="autotoc_md33"></a>
Copyright</h1>
<p>This fork with FFmpeg support copyright (C) 2017-2021 Norbert Schlia (<a href="#" onclick="location.href='mai'+'lto:'+'nsc'+'hl'+'ia@'+'ob'+'liv'+'io'+'n-s'+'of'+'twa'+'re'+'.de'; return false;">nschl<span style="display: none;">.nosp@m.</span>ia@o<span style="display: none;">.nosp@m.</span>blivi<span style="display: none;">.nosp@m.</span>on-s<span style="display: none;">.nosp@m.</span>oftwa<span style="display: none;">.nosp@m.</span>re.d<span style="display: none;">.nosp@m.</span>e</a>).</p>
<p>Based on work Copyright (C) 2006-2008 David Collett, 2008-2013 K. Henriksson.</p>
<p>This is free software: you are free to change and redistribute it under the terms of the GNU General Public License (GPL) version 3 or later. </p>
</div></div><!-- contents -->
</div><!-- PageDoc -->
<!-- start footer part -->
<hr class="footer"/><address class="footer"><small>
Generated by&#160;<a href="https://www.doxygen.org/index.html"><img class="footer" src="doxygen.svg" width="104" height="31" alt="doxygen"/></a> 1.9.1
</small></address>
</body>
</html>
